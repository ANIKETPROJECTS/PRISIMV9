# PRISM - Post-Production Management System
## COMPREHENSIVE TECHNICAL DOCUMENTATION & SYSTEM MANUAL

### 1. INTRODUCTION & HIGH-LEVEL SYSTEM ARCHITECTURE

#### 1.1 SYSTEM OVERVIEW
The PRISM (Post-Production Management System) is an enterprise-grade, integrated digital platform meticulously engineered to resolve the operational and administrative complexities inherent in professional post-production studios. In the high-stakes environment of film and media production, where time-sensitive workflows and high-value resource allocation are critical to profitability, PRISM serves as the central "nervous system." It provides a unified, real-time interface for studio administrators, operations managers, editors, and accounting departments to coordinate activities seamlessly.

The system is designed to replace disparate spreadsheets and manual tracking methods with a robust, centralized database that handles everything from the initial booking request to the final financial chalan (billing document). By automating conflict detection and providing deep analytical reports, PRISM empowers studios to maximize their room and editor utilization while minimizing scheduling errors.

#### 1.2 ARCHITECTURAL PHILOSOPHY
The architecture of PRISM is built upon a modern, full-stack JavaScript/TypeScript paradigm. The primary engineering goal was to create a system that is highly reactive, strictly typed, and easily maintainable. 

- **Single Source of Truth (SSOT)**: The database schema, defined via Drizzle ORM, acts as the definitive reference point for the entire application. All data models, validation rules, and TypeScript interfaces are derived from this single source, ensuring that the frontend and backend are always in perfect synchronization.
- **Layered Decoupling**: The application is strictly partitioned into three distinct layers:
    - **Presentation Layer (React)**: Focused purely on UI rendering and user interaction.
    - **Service Layer (Express/Storage)**: Handles business logic, data validation, and permission enforcement.
    - **Persistence Layer (PostgreSQL)**: Manages data storage with high relational integrity.
- **Reactive Synchronization**: Using TanStack Query, the frontend does not just "fetch" data; it synchronizes its local state with the server, providing optimistic updates and intelligent background refreshing to ensure users always see the latest information without manual page reloads.

#### 1.3 DETAILED TECHNOLOGY STACK
The selection of technologies for PRISM was driven by the need for industrial-strength reliability and a developer-friendly ecosystem.

**Frontend Infrastructure:**
- **React v18**: Leverages the latest concurrent rendering features to maintain a highly responsive UI, even when handling large datasets in the Operations calendar.
- **Tailwind CSS v4**: Provides a utility-first styling engine that ensures design consistency across hundreds of UI elements while keeping the final CSS bundle size minimal.
- **Shadcn UI**: A collection of high-quality, accessible UI primitives (modals, dropdowns, form controls) that give PRISM its professional, enterprise-grade aesthetic.
- **TanStack Query v5**: The "missing data-fetching library" for React, managing cache invalidation, loading states, and error handling for all API interactions.
- **Wouter**: A minimalist routing library that provides high-speed client-side navigation with a very small memory footprint compared to traditional routers.

**Backend Infrastructure:**
- **Node.js**: Provides the event-driven, non-blocking I/O runtime required for high-concurrency API handling.
- **Express.js**: A minimal and flexible web framework that serves as the backbone for the RESTful API endpoints.
- **Passport.js & Express-Session**: Implements a secure, session-based authentication flow. Sessions are persisted in the PostgreSQL database, ensuring that logins remain active across server restarts.
- **Zod**: Used for runtime schema validation. Every piece of data entering the system is validated against a Zod schema, preventing "dirty data" from reaching the database.

**Persistence & Tooling:**
- **PostgreSQL**: Chosen for its legendary reliability and support for complex relational queries, which are essential for the system's reporting and conflict detection engines.
- **Drizzle ORM**: A modern TypeScript ORM that provides the type safety of an ORM with the performance and transparency of raw SQL.
- **Vite**: The build tool and development server that provides near-instantaneous hot-module replacement (HMR) during the engineering process.

#### 1.4 GLOBAL SYSTEM COMPONENTS
PRISM is organized into several high-level modules, each designed to handle a specific vertical of studio management:

1.  **The Operations Core**: The transactional heart of the system. This module manages the real-time calendar, scheduling conflict logic, and the transition of bookings into financial documents.
2.  **The Masters Repository**: The static data management hub. It stores and organizes all reference entities, including client profiles, project hierarchies, studio room specifications, and the roster of technical staff (editors).
3.  **The Intelligence Layer**: A suite of analytical tools designed to transform raw booking data into actionable insights, such as utilization heatmaps and conflict audits.
4.  **The Administrative Console**: The control center for the platform, where administrators manage user accounts, roles, and granular permission mappings to ensure data security.

### 2. DETAILED INSTALLATION & ENVIRONMENT CONFIGURATION

#### 2.1 SERVER INFRASTRUCTURE PREPARATION
To ensure optimal performance and stability of the PRISM system, the target environment must meet specific technical benchmarks.

**Operating System**: Linux-based environments (Ubuntu 22.04 LTS or Debian 12 recommended) are preferred for production. macOS and Windows (via WSL2) are supported for development.
**Hardware Specifications**: 
- **CPU**: 2+ Cores recommended for concurrent request handling.
- **RAM**: 4GB minimum (8GB recommended for larger studios with high reporting volume).
- **Disk**: 20GB SSD for application files and database storage.

#### 2.2 POSTGRESQL DATABASE INITIALIZATION
PRISM requires a dedicated PostgreSQL instance. Follow these steps for a secure setup:

1.  **Installation**:
    ```bash
    # Ubuntu/Debian
    sudo apt update
    sudo apt install postgresql postgresql-contrib
    ```
2.  **Service Management**:
    ```bash
    sudo systemctl start postgresql
    sudo systemctl enable postgresql
    ```
3.  **Role & Database Creation**:
    Log in as the postgres superuser:
    ```bash
    sudo -u postgres psql
    ```
    Execute the following secure SQL sequence:
    ```sql
    -- Create the production database
    CREATE DATABASE prism_production;
    
    -- Create a dedicated application user
    CREATE USER prism_service_user WITH PASSWORD 'your_strong_password_here';
    
    -- Assign privileges
    GRANT ALL PRIVILEGES ON DATABASE prism_production TO prism_service_user;
    
    -- Connect to the new database to grant schema permissions
    \c prism_production
    GRANT ALL ON SCHEMA public TO prism_service_user;
    ```

#### 2.3 APPLICATION DEPLOYMENT STEPS
Once the database is ready, proceed with the application installation:

1.  **Dependency Installation**:
    Navigate to the project root and execute:
    ```bash
    npm install
    ```
    This will install all required Node.js modules including the specialized Drizzle ORM and Vite build tools.

2.  **Environment Variable Configuration**:
    Create a `.env` file in the root directory. This file is critical for the application's secure operation:
    ```env
    # Database Connection String
    DATABASE_URL=postgres://prism_service_user:your_strong_password_here@localhost:5432/prism_production
    
    # Session Security (Generate a long random string)
    SESSION_SECRET=a_highly_secure_random_string_generator_output
    
    # Environment Mode
    NODE_ENV=production
    
    # Server Port (Default: 5000)
    PORT=5000
    ```

3.  **Database Schema Synchronization**:
    PRISM uses a migration-less "Push" strategy for rapid development and stable production syncing. Execute:
    ```bash
    npm run db:push
    ```
    This command inspects your PostgreSQL database and updates the schema to match the `shared/schema.ts` definition without losing data.

4.  **Production Compilation**:
    Generate the optimized, minified production assets:
    ```bash
    npm run build
    ```
    This creates a `dist/` directory containing the compiled server-side TypeScript and the bundled React frontend.

5.  **Running the Service**:
    For production, use a process manager like **PM2** to ensure the service restarts automatically if it crashes or the server reboots:
    ```bash
    # Install PM2 globally
    npm install -g pm2
    
    # Start the application
    pm2 start dist/index.cjs --name prism-production
    
    # Enable startup persistence
    pm2 save
    pm2 startup
    ```

### 3. OPERATIONS MODULE: BUSINESS LOGIC & WORKFLOWS

#### 3.1 THE SCHEDULING HUB (BOOKING SYSTEM)
The Booking system is the most complex component of PRISM, designed to handle the high-velocity scheduling needs of a post-production studio.

**Detailed Workflow & Logic**:
1.  **Request Initiation**: A booking begins with the selection of a Date, Room, and Project. The interface utilizes a high-density calendar to prevent data entry errors.
2.  **Resource Allocation**: The user assigns an Editor to the session. The system pulls only "Active" editors from the Master roster.
3.  **Temporal Definition**: Start and End times are defined. PRISM supports 24-hour operations, handling overnight sessions correctly in duration calculations.
4.  **Conflict Validation (The Engine)**:
    Before a booking is saved, the `checkBookingConflicts` method in `server/storage.ts` performs a multi-point inspection:
    - **Room Conflict**: Checks if the selected room is already occupied during the requested interval. This involves an overlapping time interval query: `(start1 < end2) AND (end1 > start2)`.
    - **Editor Conflict**: Checks if the assigned editor is already scheduled in another room.
    - **Leave Check**: Interrogates the `editor_leaves` table to ensure the editor isn't on vacation or sick leave.
    - **Override Mechanism**: Certain "Super-User" roles can check an "Ignore Conflict" flag for specialized overlapping sessions or administrative adjustments.
5.  **Status Transitions**: 
    - **Planning**: Initial draft state.
    - **Tentative**: Room held but client hasn't confirmed.
    - **Confirmed**: Firm schedule; blocks all conflicting resources.
    - **Cancelled**: Frees up resources while maintaining the record for cancellation reports.
6.  **Persistence & Audit**: Upon successful validation, the record is saved to the `bookings` table, and an entry is automatically generated in `booking_logs` detailing the creation event, the user ID, and the initial state.

#### 3.2 CHALAN (BILLING) GENERATION & MANAGEMENT
PRISM transforms operational data into financial documents through the Chalan module. This bridge ensures that every billable minute in the studio is captured and accounted for.

**The Chalan Lifecycle**:
- **Drafting & Aggregation**: Users select one or more completed bookings to include in a Chalan. The system provides an "Aggregate" view where multiple sessions for the same project can be billed in a single document.
- **Hour Calculation Logic**: The system automatically calculates "Total Billable Hours" by:
    - Determining the gross duration (To Time - From Time).
    - Subtracting "Break Hours" (stored as decimal hours or HH:mm).
    - Applying "Actual" times if they differ from "Booked" times.
- **Itemization & Rates**: Every Chalan can have multiple line items. The system allows for:
    - Primary service billing (e.g., "Color Grading - Session").
    - Ancillary charges (e.g., "Hard Drive Backup", "Courier").
    - Manual rate overrides for special client agreements.
- **Document Revisioning**:
    Post-production chalans are frequently revised due to change requests. PRISM handles this through a dedicated `chalan_revisions` table. When a chalan is edited:
    1.  A snapshot of the current state is stored.
    2.  The `is_revised` flag is set to true.
    3.  The `revisionNumber` is incremented.
    4.  A detailed log of "Old Value vs. New Value" is created for audit purposes.
- **Cancellation Protocol**: For audit integrity, chalans cannot be deleted. They must be "Cancelled" with a mandatory reason. This ensures that the Chalan Number sequence remains traceable and no billing data "disappears" without a record.

#### 3.3 EDITOR LEAVE & AVAILABILITY
Leaves are more than just notes; they are functional barriers in the scheduling engine.
- **Validation during Entry**: When a leave is added, the system checks if that editor already has bookings during that period and warns the administrator.
- **Calendar Integration**: Leaves are visually represented on the main operation calendar, allowing managers to see at a glance who is unavailable.

### 4. MASTERS MODULE: DATA MANAGEMENT & RELATIONSHIPS

#### 4.1 CUSTOMER & CONTACT HIERARCHY
The `customers` table is the root of the financial and relationship hierarchy. 

- **Organization Profiles**: Stores GST numbers (essential for Indian tax compliance), addresses, and PAN details.
- **Multi-Contact Management**: 
    - Links to `customer_contacts`.
    - Stores Name, Phone, Email, and Designation (Producer, Accountant, etc.).
    - **Primary Flag**: Determines which contact is the default recipient for financial documents.
- **Relational Integrity**: Customers cannot be deleted if they have active bookings or chalans, preventing orphaned data records.

#### 4.2 PROJECT LIFE CYCLE
Projects are scoped per customer, creating a clean organizational structure.
- **Project Types**: Movie, Serial, Web Series, Ad, Teaser, Trilogy. These enums ensure standardized reporting across different production sectors.
- **Tracking Flags**: `hasChalanCreated` and `hasInvoiceCreated` provide quick status indicators in the Project Master list.
- **Inactivity Logic**: Completed projects are marked as `isActive = false`, which removes them from the "New Booking" dropdown while preserving all historical billing and scheduling data.

#### 4.3 RESOURCE MASTERS (ROOMS & EDITORS)
- **Room Specifications**: 
    - Categorized by type: Sound, Music, VFX, Client Office, Editing, Dubbing, Mixing.
    - Capacity tracking for seating/workstation management.
    - "Ignore Conflict" default setting for specific rooms that allow concurrent sessions.
- **Editor Profiles**: 
    - Specialized skill tracking (Video, Audio, VFX, Colorist, DI).
    - Contact info and tenure tracking (Join/Leave dates).
    - Integrated utilization history linking back to `bookings`.

### 5. REPORTS & ANALYTICAL INTELLIGENCE

#### 5.1 CONFLICT ANALYSIS REPORT
A proactive tool for studio managers to identify scheduling overlaps. 
- **Time Window Filtering**: View conflicts for today, this week, or custom ranges.
- **Resolution Path**: Direct links from the conflict report to the offending bookings for immediate adjustment.

#### 5.2 BOOKING & UTILIZATION REPORTS
- **Editor Utilization**: Shows billable hours vs. idle time per editor, crucial for resource planning.
- **Room Occupancy**: Visualizes which rooms are under-performing or reaching capacity.
- **Export Capabilities**: All reports utilize the `xlsx` library to generate native Excel files, allowing for advanced secondary analysis.

#### 5.3 CHALAN & FINANCIAL REPORTS
- **Revenue Summary**: Total billing per client/project.
- **Cancelled Chalan Audit**: Tracking lost revenue or billing errors.
- **Revised Chalan Audit**: Monitoring the frequency of billing adjustments.

### 6. SECURITY, PERMISSIONS & AUDIT LOGGING

#### 6.1 AUTHENTICATION ARCHITECTURE
- **PIN-Based Security**: Users authenticate using a Username + Security PIN. This provides a balance between security and the high-speed requirements of a studio floor.
- **Session Store**: Uses `connect-pg-simple` to store sessions directly in PostgreSQL. This ensures that users remain logged in even if the backend process restarts (e.g., during a deployment).
- **Sensitive Data Isolation**: The `users` table contains `password` and `securityPin`, but these fields are strictly filtered out in all API responses using TypeScript `omit` and manual sanitization.

#### 6.2 GRANULAR PERMISSION MODEL (RBAC)
PRISM implements a complex Role-Based Access Control system:
- **Default Roles**:
    - **Admin**: Full system access.
    - **GST**: Full Master access, Booking access, but restricted Chalan access.
    - **Non-GST**: Operation-focused; cannot view or edit financial data.
    - **Account**: Focus on Chalans and Reports; restricted Masters access.
- **Custom Role & The Permission Matrix**:
    - For the "Custom" role, administrators can toggle View, Create, Edit, and Delete permissions for every single module independently.
    - This is handled by the `user_module_access` table and enforced by the `requirePermission` middleware on the backend.

#### 6.3 AUDIT TRAIL & HISTORY
Transparency is a core feature of PRISM.
- **`booking_logs`**: Every change to a booking creates a permanent record: `Action`, `Changes` (JSON-stringified old vs new values), `User`, and `Timestamp`.
- **System History**: A global history view that aggregates logs from across the system, providing a "Timeline" of studio activity.

### 7. API DOCUMENTATION & DATABASE SCHEMA

#### 7.1 CORE API ENDPOINTS
- **Auth**: `/api/auth/login`, `/api/auth/logout`, `/api/auth/session`.
- **Operations**: `/api/bookings`, `/api/bookings/check-conflicts`, `/api/bookings/:id/cancel`, `/api/chalans`, `/api/chalans/:id/revisions`.
- **Masters**: `/api/customers`, `/api/projects`, `/api/rooms`, `/api/editors`.
- **Admin**: `/api/users`, `/api/users/:id/access`, `/api/admin/companies`.

#### 7.2 DATABASE SCHEMA (DRIZZLE ORM)
The schema utilizes PostgreSQL's advanced features:
- **Generated Identity Columns**: For all Primary Keys.
- **Native Enums**: For roles, project types, room types, and booking statuses.
- **Foreign Key Constraints**: With `references()` and `onDelete()` logic to ensure relational integrity.
- **Numeric Types**: For accurate financial and time duration calculations.

### 8. FRONTEND DESIGN SYSTEM & GUIDELINES

#### 8.1 DESIGN PHILOSOPHY
The PRISM UI is designed for high-density information management without overwhelming the user.
- **Consistent Grid**: 8px based spacing for all padding and margins.
- **Interactive Feedback**: 
    - `hover-elevate`: Subtle 3D-like lift on hover.
    - `active-elevate-2`: Distinct press-down effect for buttons.
- **Color Palette**: Utilizes a semantic theme (Primary, Secondary, Accent) that automatically adjusts for Light/Dark modes.

#### 8.2 COMPONENT ARCHITECTURE
- **`DataTable`**: A high-performance, reusable grid with built-in sorting, filtering, and pagination.
- **`PermissionGuard`**: A wrapper component that conditionally renders UI elements based on the current user's rights.
- **`BookingForm`**: A stateful, complex form that handles real-time conflict checking via debounced API calls.

### 9. MAINTENANCE & SCALING

#### 9.1 DATABASE BACKUPS
Regular backups of the `prism_production` database should be performed using `pg_dump`:
```bash
pg_dump -U prism_service_user prism_production > backup_$(date +%Y%m%d).sql
```

#### 9.2 SYSTEM UPDATES
To update the system with new code:
1. `git pull`
2. `npm install`
3. `npm run build`
4. `pm2 restart prism-production`

### 10. DETAILED MODULE-BY-MODULE FUNCTIONAL SPECIFICATION

#### 10.1 Operations Deep-Dive: The Booking Engine Logic
The booking engine is the core intelligence of PRISM. It handles high-concurrency scheduling while ensuring resource integrity.

**10.1.1 Conflict Detection Algorithms**
The backend `checkBookingConflicts` method is the system's gatekeeper. It executes three parallel checks:
1.  **Room Overlap Check**:
    Queries the `bookings` table for any existing records in the same room on the same date where the requested time window `[fromTime, toTime]` overlaps with an existing interval.
2.  **Editor Overlap Check**:
    Ensures that an editor is not booked in two different rooms at the same time. The studio's staff is its most expensive resource; PRISM ensures they are never double-tasked.
3.  **Leave Overlap Check**:
    Cross-references the `editor_leaves` table. If an editor has a recorded leave that encompasses the booking date, the system raises a "Hard Conflict" alert.

**10.1.2 The "Repeat Booking" Feature**
For long-running sessions (e.g., a movie grade taking 10 days), PRISM allows for automated repetition.
- **Daily/Weekly Patterns**: Users can specify the frequency and duration.
- **Occurrence Validation**: The system validates *every* date in the repeat sequence. If a conflict occurs on Day 4, the user is notified immediately, allowing them to adjust that specific day or skip it.

**10.1.3 Actual vs. Booked Time Tracking**
Production schedules are fluid. PRISM tracks both the "Booked" slot (for planning) and the "Actual" slot (for billing).
- **Billing Priority**: The Chalan module automatically prioritizes "Actual" times if they are provided, ensuring clients are billed for the exact duration of studio usage.

#### 10.2 Masters Deep-Dive: Relational Data Governance
The Masters module ensures that the system's foundation is built on high-quality, standardized data.

**10.2.1 Customer & Contact Management**
Customers are stored with comprehensive metadata:
- **Financial Details**: GST numbers, PAN details, and full billing addresses are mandatory for accurate invoicing.
- **Contact Designations**: Contacts are categorized (e.g., "Producer", "Post Producer", "Accountant"). This allows the system to intelligently pull the right person into the Chalan document.

**10.2.2 Room & Editor Categorization**
Resources are categorized by their technical capability:
- **Specialization Matching**: When booking a "DI Suite," the system can be configured to only suggest "Colorist" or "DI Editor" types.
- **Room Capacity**: Tracks physical limitations to prevent booking large production teams into small edit suites.

#### 10.3 Reports Deep-Dive: Analytical Intelligence & Exporting

**10.3.1 The Conflict Audit Trail**
The conflict report identifies not just current issues but historical patterns.
- **Resolution Tracking**: Studio managers can see when a conflict was identified and how it was resolved (e.g., "Moved to Room 2" or "Editor replaced").

**10.3.2 Financial Analytics (Chalan Reports)**
The system aggregates billing data to provide:
- **Revenue Summaries**: Breakdown by client, project, or date range.
- **Audit Trails**: Detailed history of chalan revisions and cancellations.

**10.3.3 Utilization Heatmaps**
Through data aggregation, the system generates visual heatmaps showing peak usage times across the week. This helps studio owners decide if they need more rooms or more staff during specific shifts.

### 11. TECHNICAL SPECIFICATION FOR DEVELOPERS

#### 11.1 Schema Definitions (Drizzle ORM)
The database structure is defined in `shared/schema.ts`. Key highlights:
- **Enums**: Used extensively for data consistency (`userRoleEnum`, `projectTypeEnum`, etc.).
- **Relationships**: Defined using Drizzle's `relations` API, enabling high-performance nested queries (e.g., "Fetch Chalan with all its Items and the linked Customer").

#### 11.2 State Management with TanStack Query
The application uses a "Query Key" based caching strategy.
- **Invalidation**: When a booking is updated, `queryClient.invalidateQueries({ queryKey: ["/api/bookings"] })` is called, triggering a background refresh across all open client browsers.
- **Optimistic Updates**: For high-speed interactions, the UI reflects changes immediately while the server request completes in the background.

#### 11.3 Form Validation with Zod & React Hook Form
Every form is backed by a Zod schema.
- **Rules**: Mandatory fields, character limits, and complex regex (e.g., 10-digit phone number validation).
- **UX**: Standardized error messages provided by `zod-validation-error` ensure a consistent user experience.

#### 11.4 Backend Middleware Chain
API requests follow a strict execution path:
1.  **Auth Middleware**: Extracts user ID and Role from the secure session.
2.  **Permission Guard**: Checks if the user's role/permissions allow the requested action on the target module.
3.  **Zod Parser**: Validates the request body against the expected schema before it reaches the storage layer.
4.  **Controller Logic**: Interacts with `storage.ts` to perform database operations and returns a standardized JSON response.

---
*This document serves as the authoritative guide for the PRISM Post-Production Management System. All code modifications should adhere to the architectural patterns defined herein.*
